(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{518:function(e,r,t){"use strict";t.r(r);var s=t(6),a=Object(s.a)({},(function(){var e=this,r=e.$createElement,t=e._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"异步编程解决方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#异步编程解决方案"}},[e._v("#")]),e._v(" 异步编程解决方案")]),e._v(" "),t("p",[e._v("异步的意义：非阻塞 IO 操作，页面始终能响应用户的操作。")]),e._v(" "),t("h3",{attrs:{id:"promise-的实现原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise-的实现原理"}},[e._v("#")]),e._v(" Promise 的实现原理")]),e._v(" "),t("ul",[t("li",[e._v("避免出现层层嵌套的回调函数")]),e._v(" "),t("li",[e._v("拥有统一的接口，控制异步操作更容易")]),e._v(" "),t("li",[e._v("Promise 拥有三种状态\n"),t("ul",[t("li",[e._v("pending（进行中）")]),e._v(" "),t("li",[e._v("fulfilled（已成功）")]),e._v(" "),t("li",[e._v("rejected（已失败）")])])])]),e._v(" "),t("h4",{attrs:{id:"promise-prototype-then"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise-prototype-then"}},[e._v("#")]),e._v(" Promise.prototype.then()")]),e._v(" "),t("ul",[t("li",[e._v("Promise 构造函数的原对象上有 then 方法：Promise.prototype.then")]),e._v(" "),t("li",[e._v("then 方法返回值：新的 Promise 实例（因此可以使用链式写法）")]),e._v(" "),t("li",[e._v("then 接受两个参数\n"),t("ul",[t("li",[e._v("resolved 状态的回调函数")]),e._v(" "),t("li",[e._v("rejected 状态的回调函数")])])])]),e._v(" "),t("h4",{attrs:{id:"promise-prototype-catch"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise-prototype-catch"}},[e._v("#")]),e._v(" Promise.prototype.catch()")]),e._v(" "),t("ul",[t("li",[e._v("上述 then 方法的 rejected 状态的回调函数\n"),t("ul",[t("li",[e._v(".then(null, rejection)")]),e._v(" "),t("li",[e._v("Promise.prototype.catch()方法指定发生错误时的回调函数。")])])])]),e._v(" "),t("h4",{attrs:{id:"promise-prototype-finally"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise-prototype-finally"}},[e._v("#")]),e._v(" Promise.prototype.finally()")]),e._v(" "),t("ul",[t("li",[e._v("finally()方法用于指定不管 Promise 对象最后状态如何，都会执行的操作")])]),e._v(" "),t("h4",{attrs:{id:"promise-all"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise-all"}},[e._v("#")]),e._v(" Promise.all()")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("const p = Promise.all([p1, p2, p3]);")])]),e._v(" "),t("li",[e._v("Promise.all()方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。")]),e._v(" "),t("li",[e._v("Promise.all()方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。")])]),e._v(" "),t("h4",{attrs:{id:"promise-resolve-参数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise-resolve-参数"}},[e._v("#")]),e._v(" Promise.resolve(参数)")]),e._v(" "),t("ul",[t("li",[e._v("四种参数\n"),t("ul",[t("li",[e._v("Promise 实例，"),t("strong",[e._v("返回该实例")])]),e._v(" "),t("li",[e._v("thenable 对象，"),t("strong",[e._v("将这个对象转为 Promise 对象，然后就立即执行 thenable 对象的 then 方法。")])]),e._v(" "),t("li",[e._v("其他情况以该值为成功状态返回一个 Promise 对象。")])])])]),e._v(" "),t("h4",{attrs:{id:"promise-reject"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise-reject"}},[e._v("#")]),e._v(" Promise.reject()")]),e._v(" "),t("ul",[t("li",[e._v("Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为 rejected。")])]),e._v(" "),t("h3",{attrs:{id:"async-await-的实现原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#async-await-的实现原理"}},[e._v("#")]),e._v(" async/await 的实现原理")]),e._v(" "),t("p",[e._v("async 是 Generator 函数的语法糖")]),e._v(" "),t("h3",{attrs:{id:"generator-的实现原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#generator-的实现原理"}},[e._v("#")]),e._v(" Generator 的实现原理")]),e._v(" "),t("h3",{attrs:{id:"实现-promise"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实现-promise"}},[e._v("#")]),e._v(" 实现 Promise")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("Promise 大致框架解构（三部分）")]),e._v(" "),t("ul",[t("li",[e._v("then 收集依赖")]),e._v(" "),t("li",[e._v("异步触发 resolve")]),e._v(" "),t("li",[e._v("resolve 执行依赖")])])]),e._v(" "),t("li",[t("p",[e._v("Promise 三种状态值 （状态值改变）")]),e._v(" "),t("ul",[t("li",[e._v("Promise 本质是一个状态机，且状态只能为以下三种：\n"),t("ul",[t("li",[e._v("Pending（等待态）、Fulfilled（执行态）、Rejected（拒绝态）")]),e._v(" "),t("li",[e._v("只能从 Pending -> Fulfilled 或 Pending -> Rejected，")]),e._v(" "),t("li",[e._v("状态的变更是单向的,状态变更不可逆")])])])])]),e._v(" "),t("li",[t("p",[e._v("Promise then 链式调用")]),e._v(" "),t("ul",[t("li",[e._v("then 方法接收两个可选参数，分别对应状态改变时触发的回调。")]),e._v(" "),t("li",[e._v("then 方法返回一个 promise。")]),e._v(" "),t("li",[e._v("then 方法可以被同一个 promise 调用多次。")])])])]),e._v(" "),t("h2",{attrs:{id:"参考资料"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[e._v("#")]),e._v(" 参考资料")]),e._v(" "),t("ul",[t("li",[t("p",[t("a",{attrs:{href:"https://es6.ruanyifeng.com/#docs/promise",target:"_blank",rel:"noopener noreferrer"}},[e._v("ECMAScript 6 入门"),t("OutboundLink")],1)])]),e._v(" "),t("li",[t("p",[t("a",{attrs:{href:"https://juejin.im/post/5e3b9ae26fb9a07ca714a5cc#heading-2",target:"_blank",rel:"noopener noreferrer"}},[e._v("9k 字 | Promise/async/Generator 实现原理解析"),t("OutboundLink")],1)])])])])}),[],!1,null,null,null);r.default=a.exports}}]);